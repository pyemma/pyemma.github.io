var store = [{
        "title": "Ant Cheat Sheet",
        "excerpt":"This is a simple document introducing how to write the build.xml of Ant for your projects.Each Ant build.xml has a &lt;project&gt; element as the root element, this element can have a name attribute, which specify the name of this project; a basedir element, which determines the root path during the...","categories": [],
        "tags": ["project","tools"],
        "url": "https://pyemma.github.io/Ant-Cheat-Sheet/",
        "teaser":"https://pyemma.github.io/assets/violet.jpg"},{
        "title": "[Lintcode] Triangle Count",
        "excerpt":"Given an array of integers, how many three numbers can be found in the array, so that we can build an triangle whose three edges length is the three numbers that we find?The most naive solution is to enumerate all triples and then check if they can construct a triangle...","categories": [],
        "tags": ["algorithm","interview"],
        "url": "https://pyemma.github.io/Lintcode-Triangle-Count/",
        "teaser":"https://pyemma.github.io/assets/violet.jpg"},{
        "title": "Simple Bloom Filter Implementation Part I",
        "excerpt":"Recently, I’m studying some basic concepts in distributed system. The materials I’m using is Distributed Systems Concepts. I know that simply reading the book is far not enough: the concepts are abstract, but we need to handle partical problem. So I decided to do some simple projects, using some existing...","categories": [],
        "tags": ["project","distributed system","data structure"],
        "url": "https://pyemma.github.io/Simple-Bloom-Filter-Implementation-Part-I/",
        "teaser":"https://pyemma.github.io/assets/violet.jpg"},{
        "title": "Simple Bloom Filter Implementation Part 2",
        "excerpt":"IntroductionIn the last blog, we introduced the initial version of bloom filter. In the first implementation, we only tested our bloom filter on built in type String. This time, we tested in against a custom class Person. The idea is simple: we use thrift to define our custom data structure....","categories": [],
        "tags": ["project","distributed system","data structure"],
        "url": "https://pyemma.github.io/Simple-Bloom-Filter-Implementation-Part-2/",
        "teaser":"https://pyemma.github.io/assets/violet.jpg"},{
        "title": "[Hackerrank] Cut the tree",
        "excerpt":"The problem is available here. The idea is to use postorder traversal of the tree to enumerate each possible remove of edge, and return the sum of the sub-tree to its parent node. This problem represent the tree as a acyclic undirected graph, which is a quite wired representation.public class...","categories": [],
        "tags": ["algorithm","interview"],
        "url": "https://pyemma.github.io/Hackerrank-Cut-the-tree/",
        "teaser":"https://pyemma.github.io/assets/violet.jpg"},{
        "title": "[Lintcode] Count of Smaller Number before itself",
        "excerpt":"Give you an integer array (index from 0 to n-1, where n is the size of this array, value from 0 to 10000) . For each element Ai in the array, count the number of element before this element Ai is smaller than it and return count number array.In this...","categories": [],
        "tags": ["algorithm","interview"],
        "url": "https://pyemma.github.io/Lintcode-Count-of-Smaller-Number-before-itself/",
        "teaser":"https://pyemma.github.io/assets/violet.jpg"},{
        "title": "[Lintcode] Interval Sum II",
        "excerpt":"Given an integer array in the construct method, implement two methods query(start, end) and modify(index, value): For query(start, end), return the sum from index start to index end in the given array. For modify(index, value), modify the number in the given index to value public class Solution { private TreeNode...","categories": [],
        "tags": ["algorithm","interview"],
        "url": "https://pyemma.github.io/Lintcode-Interval-Sum-II/",
        "teaser":"https://pyemma.github.io/assets/violet.jpg"},{
        "title": "[CodeFights] NumberGameVI",
        "excerpt":"The problem is available here. A relatively straight forward game problem. If the current person want to win, the only requirement is that there exist a move can make B lose. And if there is no move can make B lose, then A will lose. Translate this into recursion and...","categories": [],
        "tags": ["algorithm","interview"],
        "url": "https://pyemma.github.io/CodeFights-NumberGameVI/",
        "teaser":"https://pyemma.github.io/assets/violet.jpg"},{
        "title": "Design Pattern Summarization",
        "excerpt":"Design Pattern SummarizationStrategy PatternDefines a family of algorithms, encapsulate each one, and makes them interchangeable. Strategy lets the algorithm vary independently from clients that use it.[Image: file:///-/blob/eDDAAAJA4tZ/2DMfZKq387ZdSBlQHdKHXg]Use composition instead of inheritance to separate the detailed actions from the clients code. The detailed actions can be determined or changed in run...","categories": [],
        "tags": [],
        "url": "https://pyemma.github.io/Design-Pattern-Summarize/",
        "teaser":"https://pyemma.github.io/assets/violet.jpg"},{
        "title": "Clean Code Summarize",
        "excerpt":"Here is just some tips I think is most useful for guiding me to write better code from book Clean Code: A Handbook of Agile Software Craftsmanship.##NamingWe cannot avoid naming things well we are writing code, a good name can considerably increase the readability of the code. We even does...","categories": [],
        "tags": [],
        "url": "https://pyemma.github.io/Clean-Code-Summarize/",
        "teaser":"https://pyemma.github.io/assets/violet.jpg"},{
        "title": "Math Equation",
        "excerpt":"Use $$ to write math equation\\[\\sum_{n=1}^\\infty 1/n^2 = \\frac{\\pi^2}{6}\\]\\[\\textbf{A}\\textbf{B} = \\textbf{C}\\]Use \\begin{equation} to write math equation\\begin{equation}\\sum_{n=1}^\\infty 1/n^2 = \\frac{\\pi^2}{6}\\end{equation}\\[\\begin{align*} &amp; \\phi(x,y) = \\phi \\left(\\sum_{i=1}^n x_ie_i, \\sum_{j=1}^n y_je_j \\right) = \\sum_{i=1}^n \\sum_{j=1}^n x_i y_j \\phi(e_i, e_j) = \\\\ &amp; (x_1, \\ldots, x_n) \\left( \\begin{array}{ccc} \\phi(e_1, e_1) &amp; \\cdots &amp; \\phi(e_1, e_n)...","categories": [],
        "tags": [],
        "url": "https://pyemma.github.io/Math-Equation/",
        "teaser":"https://pyemma.github.io/assets/violet.jpg"},{
        "title": "Reinforcement Learning Lesson 1",
        "excerpt":"This is the first post for the series reinforcement learning. The main source for the entire series is here. The post mainly focus on summarizing the content introduced in the video and slides, as well as some of my own understanding. Any feedback is welcomed.In this post, we will talk...","categories": [],
        "tags": [],
        "url": "https://pyemma.github.io/Reinforcement-Learning-Lesson-1/",
        "teaser":"https://pyemma.github.io/assets/violet.jpg"},{
        "title": "Reinforcement Learning Lesson 2",
        "excerpt":"In the last post, we introduced the definition of Markov Decision Process and Bellman Equation. Now, if you are given the states \\( S \\), action $A$, transition matrix $P$, rewards $R$ and discounting ratio \\( \\gamma \\), how would you come up with a solution for this MDP? i.e....","categories": [],
        "tags": [],
        "url": "https://pyemma.github.io/Reinforcement-Learning-Lesson-2/",
        "teaser":"https://pyemma.github.io/assets/violet.jpg"},{
        "title": "Reinforcement Learning Lesson 3",
        "excerpt":"In this lesson, we will learn about what to do when we have no knowledge about the MDP. In the last lesson, we learnt about how to solve a MDP when we have full information about it (e.g. $P$, $R$). When we don’t have enough information, the Bellman Equation won’t...","categories": [],
        "tags": [],
        "url": "https://pyemma.github.io/Reinforcement-Learning-Lession-3/",
        "teaser":"https://pyemma.github.io/assets/violet.jpg"},{
        "title": "Reinforcement Learning Lesson 4",
        "excerpt":"In this lecture, we learn how to solve an unknown MDP. In the last lecture, we introduced how to calculate the value function given a policy. In this one, we will try to find the optimize policy by ourselves.Mento Calro Policy IterationIn the Lesson 2, we mentioned how to solve...","categories": [],
        "tags": [],
        "url": "https://pyemma.github.io/Reinforcement-Learning-Lesson-4/",
        "teaser":"https://pyemma.github.io/assets/violet.jpg"},{
        "title": "Reinforcement Learning Lesson 5",
        "excerpt":"In this post, we are going to look into how can we solve the real world problem with a practical way. Think of the state value function $v(s)$ or the action value function $q(s, a)$ we mentioned before. If the problem has a really large state space, then it would...","categories": [],
        "tags": [],
        "url": "https://pyemma.github.io/Reinforcement-Learning-Lesson-5/",
        "teaser":"https://pyemma.github.io/assets/violet.jpg"},{
        "title": "Reinforcement Learning Lesson 6",
        "excerpt":"In the pervious we use a model to approximate the state value/action value function. In this post, we are going to learn how to directly parameterize a policy, which means we would directly get the probability of each action given a state:\\[\\pi_{\\theta}(s ,a) = P[a|s, \\theta]\\]In this case, we are...","categories": [],
        "tags": ["reinforcement learning"],
        "url": "https://pyemma.github.io/Reinforcment-Learning-Lesson-6/",
        "teaser":"https://pyemma.github.io/assets/violet.jpg"},{
        "title": "Reinforcement Learning Lesson 7",
        "excerpt":"In the pervious notes, we are all using model-free reinforcement learning method to find the solution for the problem. Today we are going to introduce method that directly learns from the experience and tries to understand the underlaying world.From Lesson 1 we know that a MDP can be represent by...","categories": [],
        "tags": [],
        "url": "https://pyemma.github.io/Reinforcement-Learning-Lesson-7/",
        "teaser":"https://pyemma.github.io/assets/violet.jpg"},{
        "title": "Reinforcement Learning Lesson 8",
        "excerpt":"This is the last lesson for the entire reinforcement learning, and in this lesson we will learn something related to exploit and explore. In machine learning service, like recommendation service, there is always a trade off between exploit and explore. Exploit means we are always choosing the best given the...","categories": [],
        "tags": [],
        "url": "https://pyemma.github.io/Reinforcement-Learning-Lesson-8/",
        "teaser":"https://pyemma.github.io/assets/violet.jpg"},{
        "title": "DQN In Practice",
        "excerpt":"Recently I have been working on Deep-Q-Learning and apply it to some interesting AI games. In this post, I would like to give a brief introduction to how I implemented the Deep-Q-Learning, as well as lots of learning along the way.What is DQNTo understand DQN, we need first know is...","categories": [],
        "tags": [],
        "url": "https://pyemma.github.io/DQN-In-Practice/",
        "teaser":"https://pyemma.github.io/assets/violet.jpg"},{
        "title": "MIT Distributed System Course - MapReduce",
        "excerpt":"IntroductionThis is going to be a series of posts to record my learning of MIT 6.824 Distributed System. The post would focus on the course assignments which is to build some distributed systems from scratch using Go language. I would discuss some of the basic ideas that these assignments touched,...","categories": [],
        "tags": ["distributed system"],
        "url": "https://pyemma.github.io/Distributed-System-Map-Reduce/",
        "teaser":"https://pyemma.github.io/assets/violet.jpg"},{
        "title": "MIT Distributed System Course - Raft I",
        "excerpt":"IntroductionIn the following series of post, we are going to implement Raft consensus algorithm, which is used to manage replicated log. And on top of that, we would implement a failure tolerance key-value store. This type of failure tolerant system is called replicated state machine. Replicated state machine operates on...","categories": [],
        "tags": ["distributed system"],
        "url": "https://pyemma.github.io/Distributed-System-RAFT/",
        "teaser":"https://pyemma.github.io/assets/violet.jpg"},{
        "title": "MIT Distributed System Course - Raft II",
        "excerpt":"IntroductionIn this post, we continue our work on raft implementation. The focus of this post would be the second part of raft, which is the log replication, and snapshot to optimize the size of the log.Let’s first go through the high level logic of how log replica works in raft:...","categories": [],
        "tags": ["distributed system"],
        "url": "https://pyemma.github.io/Distributed-System-RAFT-II/",
        "teaser":"https://pyemma.github.io/assets/violet.jpg"},{
        "title": "投资小白学习读财报",
        "excerpt":"最近开始步入投资领域，打算在自己的博客里面也专门开一个版块。主要的目的一方面是做阶段性的总结，和大家交流学习；另一方面也是给自己的博客增加一些多样性，而不是单纯的技术性博客（根本没人读 TAT）。我的背景是纯粹的投资小白，属于那种连股票还有期权都分不清楚的那种24k纯投资小白，而且之前还一直不懈于搞投资。在老婆的劝（wei）说（xie）之下，终于开始尝试学习。我学习东西比较喜欢做主题性的学习，有点类似于主题阅读。通常我会找到一个主题（这个主题可能是听别人提到的，或者是在网站上偶然看到的一个主题），然后尽可能搜索相关的资料学习，最后整理一下要点。在这一篇博客里面，我就打算先介绍一下，自己最近在学习的关于阅读财报的一些要点。去哪里找财报找上市公司的财报信息有很多种的途径，在这里我介绍两种我使用过的方法： 第一种是去公司的官方网站，然后找带有investor字样的链接。以我最近在研究的Palantir这家公司来说，在他家的官网最底下，有一个 Investor Relations 的链接，如下图所示。来到新页面上之后可以找到一个叫做 Financials 的下拉选项单，在这里可以找到一个 Quartely Results 和 SEC Filing 的选项。一般我们小白读一读 Quartely Results 上的东西就可以啦：有精简版的财报，还有制作精美的 PPT 供你选择阅读。当然也可以看更加正式的财报比如 K10 年报什么的，但是那个100多页的文档读起来可真的不轻松呀。 第二中方法是使用 Yahoo Finance 网站。在搜索栏里面输入想要查询的公司的股票代码（PLTR)或者公司名字，然后我们在结果页面上能找到一个 Financials 的tab，如下图所示。在这里我们也能得到公司的财报信息。 怎么读财报财报一共有三个表格，分别是盈利表(income sheet)，资产负债表(balance sheet)和现金流表(cash flow sheet)。在看这些表的时候基本上要遵守下面的几样原则： 绝对值(absolute number)很重要，但是比例(ratio)同样很重要，甚至是更加的重要。 单纯看一年的数据不够劲儿，需要综合着看历年的数据，来观察趋势（导数啊同学们），以此来判断公司未来的发展前景。 单纯看一家公司的也还不够劲儿，需要跟同一行业的其他公司来比较，从而了解这家公司在行业内的数据是不是足够优秀。这三张表中，我个人感觉最有用的还是盈利表和资产负债表，现金流表我到现在也还没有研究透彻，所以也不敢说得太多。首先我们看看看盈利表，通过这张表我们可以知道这家公司运营的如何。首先可以看的是一家公司的营收(Revenue)。同时我们还可以看到支出(Cost of Revenue)，也就是相应的支出有多少。这两项相减，我们能得到公司的毛利润(Gross Profit)。同时我们还能从表上得到公司其他的一些operation cost，比如科研(R&amp;D)还有市场营销(Marketing)之类的。除此之外还有要交的税啥的。如果我们把这些cost也都从应收里面扣除的话，就得到了传说中的净利润(Net Profit)或者净亏损(Net Loss)。我们把毛利润还有净利润分别跟营收相除，就得到了毛利率(Gross Margin)跟净利率(Net Margin)。下面我们来看个例子，比较一下Facebook还有Snapchat这两家公司的状况。 Facebook Snapchat从上面的表格中我们可以看出，2020年全年Facebook的营收比2019年增长了大约21.59%，Snapchat则是38.16%。说明Snapchat的增长速度远远超过Facebook，这个也是比较符合我们的预期的，因为Facebook已经是一个大型的非常成熟的企业了，而Snapchat任然处于一个高速的发展阶段。这个从两家公司最后的净利润也可以看出来，Facebook是有实现盈利的，而Snapchat任然是处于亏损的状态。2020年Facebook的净利率大概是33.9%，相比较2019年的26.1%，有一个比较大的提升。这个对于科技公司来说在2020年是一个比较普遍的影响，由于疫情的影响，科技公司的业务往往实现了一个爆发式的增长。巴菲特老爷子就很看重公司的毛利率还有净利率，他的一个建议是，一个公司的毛利率在40%以上，净利率在20%以上的话，那么这个公司就是还蛮不错的。有了净利润，我们再除以全部的股东权益的话，那么就能得到每股收益(Earning Per Share)。这个不用我们自己手算，在盈利表中就已经给了。Facebook的EPS从2019年的6.48涨到了10.22，实现了57%的增长。EPS还有一个很重要的用途就是用来计算P/E值，这个值在价值投资里面是一个很重要的指标，用来衡量一家公司的股票是被高估还是低估了。在《聪明的投资者》一书中，作者就建议当P/E值超过40的时候，可以考虑卖出股票。这条建议在现在的成长股中可能不是很实用（P/E 超高的股票太多了）。Facebook的P/E值现在是26左右，Snapchat的则没有这个值，因为其EPS是负数（没有实现盈利）。不同的行业，其净利率，EPS可能会很不一样，这个是又行业本身的性质决定的。我们可以看一下苹果公司的数据，如下图所示 Apple苹果公司2020年的净利率是26%左右，比Facebook低了很多。其EPS从2019年的2.99增长到了2020年的3.31，实现了10.7%的增长。这些数据比Facebook低，但是这丝毫没有影响大家对其的喜爱。苹果公司的P/E值打到了32左右，说明投资者对于苹果公司的前景是更加看好的。这个例子就是想告诉大家，大家在比较公司的时候一定要同类别进行比较，否则数据没有什么意义（call...","categories": [],
        "tags": ["投资"],
        "url": "https://pyemma.github.io/Newbee-Learn-to-Read-Financial-Reports/",
        "teaser":"https://pyemma.github.io/assets/violet.jpg"},{
        "title": "投资小白读《聪明的投资者》/ 《投资的常识》",
        "excerpt":"作为一个投资小白，阅读一些书籍来学习一些知识还是很有必要的。在琳琅满目的投资类书籍中，我优先读了这么两本书：《聪明的投资者》和《投资的常识》。《聪明的投资者》是被誉为华尔街教父的格雷厄姆写的一本通俗易懂的面向大众的投资书籍。格老是价值投资的先驱，巴菲特的精神导师，其投资理念可见一斑。《投资的常识》是一本更加通俗易懂的小书，以朴实无华的语言，向大众传授投资的理念。这本书的两位作者也是在投资领域非常著名的人物。在这篇博客里面，我总结一些我自己读完这两本书之后感触最深刻的一些部分，起到一些抛砖引玉的作用，也希望大家能有时间亲自读一读这两本经典的书籍。《投资的常识》这本书非常的精致，作者用精简的语言，向广大个人投资者（俗称的散户），推荐了一些投资理念：  基金定投：每个月根据个人工资盈余的情况，将盈余按照固定的金额投入的基金之中。          作者在这里提到的是基金，现在的话我们有另外一种选择，也就是ETF。相比较基金来说，买卖起来更加的方便，而且现在大部分券商都不要手续费了，所以作者在书中提到的ETF的一个短板其实已经不存在了。        资产多元化：俗话所说的不要把鸡蛋都放在一个篮子里面，专业点的说法好像叫现代资产理论。多元化可以从各个层面上来进行，比如从资产的类型里面，我们可以配置一个包括股票，债券跟房地产的投资组合，这个比纯粹的股票的要更加的稳定（可能会损失一部分的收益）；在股票投资里面，我们可以购买多个板块的股票，而不是全部砸入一个公司的股票。          多元化也可以从市场的维度来进行，比如，我们不单单买美股的大盘指数，也可以买一点新兴市场的大盘指数，或者上证50指数之类的。        资产配置：既然我们要做资产多元化，那么我们就需要根据我们自己所期望的收益与风险，给不同的资产在总资产中配置不同的比例。由于不同的资产在不同的经济周期中会有不同的表现，这个比例会因此而发生变化。我们需要做的事情就是定时对资产做出调整，从而使其比例与我们最初所规划的比例一致。这个操作不需要非常的频繁，基本上每半年调整一次就可以了。  投资指数化：就是只买指数基金或者跟踪指数基金的ETF，而不是自己选择公司的股票。这个也是巴菲特老爷子对于大众投资者最最建议的投资方式了。其奢求战胜市场，获得市场的平均收益，跑赢通胀，这种简单的策略反而能战胜市场上的大多数参与者。          我们也可以对这个建议做一定的调整，比如90%的资产配置在指数基金，用剩余的10%来自己挑选股票。这样我们不仅不用承受太高的风险，每天晚上睡个安稳觉，也能享受一下智力挑战的乐趣。      《聪明的投资者》这本书我没有全部读完，而是针对性的阅读了其中一些针对被动投资者的章节。在读到的章节里面，有一些对我很有启发的内容，在这里和大家分享一下。注意，这里的内容有一部分是格老的原著，另一部分是本书的作者的点评。  针对市场波动，格老建议：不要在股价出现大幅上涨后立即购买股票，也不要在股价出现大幅下跌后立即出售股票。追涨杀跌，只能当一颗被割的韭菜。其实这条建议就是告诉我们要相信自己的判断，不要被市场上的噪音所干扰。这也是为什么格老建议我们走程式化的投资策略，因为这样比较容易管住我们自己的手。投资最大的敌人，永远都是我们自己。作者在点评中也如此说道：投资活动并非要在游戏中打败别人，而是要在游戏中管好自己。  针对普通股的分析，有以下的几个大方面          总体的长期前景，来看看这个行业是不是夕阳产业                  企业增长的原因是什么，企业现在（将来）的利润来自何方？这个和《徐远的投资课》里面分析2C行业，互联网行业的发展的底层逻辑很类似          企业是否有足够的护城河，比如品牌形象，对市场的垄断或者几乎垄断，无形资产，无法被替代等          稳定且持续的增长率（很高的增长率是不可能一直维持的）          对R&amp;D的研发投入程度                    管理层的表现                  当年画的饼，是不是做到了，还是只会说大话（想到了乐视还有特斯拉这个例子）          是不是只是在给管理层谋求利益                    财务实力和资本结构：只有普通股和大量盈余现金的公司的股票更值得持有                  过去10年的营业现金流是不是在稳定增长          过去10年，所有者收益（净收益加上摊销和折旧，再减去正常的资本支出）一直按高于6%的速度增长          长期负债低于总资本的50%                    股息记录                  不断分割股票是一个很不好的信号          公司应该在股票价值低的时候进行回购                    当期股息收益率        格老建议大家控制股票的数量，这个建议在现在仍然非常实用。最近看老李的视频，老李也说了这一点，也总结了最近投资选股过多导致没有足够的精力来跟盘，而导致了亏损。在当前的环境下，买ETF是一个蛮不错的选择。  格老也比较推荐定期的进行资产的配置，确保证券和股票能够保持一定的比例。另一个就是定期的拿出一些钱来程序化的进行股票投资。来尽可能的约束自己。计划阅读书目这两本书都是属于比入门向的书籍，而且更多的是针对投资理念而不是一些实际的技术性操作。接下来我打算好好研究一下定投这个方法，打算阅读一下《指数基金投资指南》这本书，争取在阅读完这本书籍之后，能总结出一套适用于自己的指数基金定投的方法和计划。到时候也会跟大家继续分享我的心得体会。","categories": [],
        "tags": ["投资"],
        "url": "https://pyemma.github.io/Newbee-Reading-Investment-Books-I/",
        "teaser":"https://pyemma.github.io/assets/violet.jpg"}]
