<!doctype html><html lang="en" ><head><meta http-equiv="Content-Type" content="text/html; charset=UTF-8"><meta name="theme-color" media="(prefers-color-scheme: light)" content="#f7f7f7"><meta name="theme-color" media="(prefers-color-scheme: dark)" content="#1b1b1e"><meta name="mobile-web-app-capable" content="yes"><meta name="apple-mobile-web-app-status-bar-style" content="black-translucent"><meta name="viewport" content="width=device-width, user-scalable=no initial-scale=1, shrink-to-fit=no, viewport-fit=cover" ><meta name="generator" content="Jekyll v4.3.4" /><meta property="og:title" content="How to Design Auction System" /><meta name="author" content="Coding Monkey" /><meta property="og:locale" content="en" /><meta name="description" content="In this post, let’s discuss a little bit how to design an auction system similar to the one on eBay, where owner could list their items in the system and others could place a bid on it. User with highest bid would be the winner of this auction and could buy it." /><meta property="og:description" content="In this post, let’s discuss a little bit how to design an auction system similar to the one on eBay, where owner could list their items in the system and others could place a bid on it. User with highest bid would be the winner of this auction and could buy it." /><link rel="canonical" href="https://pyemma.github.io/How-to-design-auction-system/" /><meta property="og:url" content="https://pyemma.github.io/How-to-design-auction-system/" /><meta property="og:site_name" content="Coding Monkey" /><meta property="og:type" content="article" /><meta property="article:published_time" content="2024-04-06T00:00:00-07:00" /><meta name="twitter:card" content="summary" /><meta property="twitter:title" content="How to Design Auction System" /><meta name="twitter:site" content="@" /><meta name="twitter:creator" content="@pyemma" /> <script type="application/ld+json"> {"@context":"https://schema.org","@type":"BlogPosting","author":{"@type":"Person","name":"Coding Monkey","url":"https://github.com/pyemma"},"dateModified":"2024-10-13T23:27:03-07:00","datePublished":"2024-04-06T00:00:00-07:00","description":"In this post, let’s discuss a little bit how to design an auction system similar to the one on eBay, where owner could list their items in the system and others could place a bid on it. User with highest bid would be the winner of this auction and could buy it.","headline":"How to Design Auction System","mainEntityOfPage":{"@type":"WebPage","@id":"https://pyemma.github.io/How-to-design-auction-system/"},"url":"https://pyemma.github.io/How-to-design-auction-system/"}</script><title>How to Design Auction System | Coding Monkey</title><link rel="apple-touch-icon" sizes="180x180" href="/assets/img/favicons/apple-touch-icon.png"><link rel="icon" type="image/png" sizes="32x32" href="/assets/img/favicons/favicon-32x32.png"><link rel="icon" type="image/png" sizes="16x16" href="/assets/img/favicons/favicon-16x16.png"><link rel="manifest" href="/assets/img/favicons/site.webmanifest"><link rel="shortcut icon" href="/assets/img/favicons/favicon.ico"><meta name="apple-mobile-web-app-title" content="Coding Monkey"><meta name="application-name" content="Coding Monkey"><meta name="msapplication-TileColor" content="#da532c"><meta name="msapplication-config" content="/assets/img/favicons/browserconfig.xml"><meta name="theme-color" content="#ffffff"><link rel="preconnect" href="https://fonts.googleapis.com" ><link rel="dns-prefetch" href="https://fonts.googleapis.com" ><link rel="preconnect" href="https://fonts.gstatic.com" crossorigin><link rel="dns-prefetch" href="https://fonts.gstatic.com" ><link rel="preconnect" href="https://cdn.jsdelivr.net" ><link rel="dns-prefetch" href="https://cdn.jsdelivr.net" ><link rel="stylesheet" href="/assets/css/jekyll-theme-chirpy.css"><link rel="stylesheet" href="https://fonts.googleapis.com/css2?family=Lato:wght@300;400&family=Source+Sans+Pro:wght@400;600;700;900&display=swap"><link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/@fortawesome/fontawesome-free@6.6.0/css/all.min.css"><link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/tocbot@4.29.0/dist/tocbot.min.css"><link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/loading-attribute-polyfill@2.1.1/dist/loading-attribute-polyfill.min.css"><link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/glightbox@3.3.0/dist/css/glightbox.min.css"> <script type="text/javascript"> class ModeToggle { static get MODE_KEY() { return 'mode'; } static get MODE_ATTR() { return 'data-mode'; } static get DARK_MODE() { return 'dark'; } static get LIGHT_MODE() { return 'light'; } static get ID() { return 'mode-toggle'; } constructor() { let self = this;this.sysDarkPrefers.addEventListener('change', () => { if (self.hasMode) { self.clearMode(); } self.notify(); }); if (!this.hasMode) { return; } if (this.isDarkMode) { this.setDark(); } else { this.setLight(); } } get sysDarkPrefers() { return window.matchMedia('(prefers-color-scheme: dark)'); } get isPreferDark() { return this.sysDarkPrefers.matches; } get isDarkMode() { return this.mode === ModeToggle.DARK_MODE; } get hasMode() { return this.mode != null; } get mode() { return sessionStorage.getItem(ModeToggle.MODE_KEY); }get modeStatus() { if (this.hasMode) { return this.mode; } else { return this.isPreferDark ? ModeToggle.DARK_MODE : ModeToggle.LIGHT_MODE; } } setDark() { document.documentElement.setAttribute(ModeToggle.MODE_ATTR, ModeToggle.DARK_MODE); sessionStorage.setItem(ModeToggle.MODE_KEY, ModeToggle.DARK_MODE); } setLight() { document.documentElement.setAttribute(ModeToggle.MODE_ATTR, ModeToggle.LIGHT_MODE); sessionStorage.setItem(ModeToggle.MODE_KEY, ModeToggle.LIGHT_MODE); } clearMode() { document.documentElement.removeAttribute(ModeToggle.MODE_ATTR); sessionStorage.removeItem(ModeToggle.MODE_KEY); }notify() { window.postMessage( { direction: ModeToggle.ID, message: this.modeStatus }, '*' ); } flipMode() { if (this.hasMode) { this.clearMode(); } else { if (this.isPreferDark) { this.setLight(); } else { this.setDark(); } } this.notify(); } } const modeToggle = new ModeToggle(); </script><body><aside aria-label="Sidebar" id="sidebar" class="d-flex flex-column align-items-end"><header class="profile-wrapper"> <a href="/" id="avatar" class="rounded-circle"><img src="/assets/profile.png" width="112" height="112" alt="avatar" onerror="this.style.display='none'"></a><h1 class="site-title"> <a href="/">Coding Monkey</a></h1><p class="site-subtitle fst-italic mb-0">I'm also providing coaching to help you become more success in your career, <a href="https://bit.ly/41vi77B">book a session</a></p></header><nav class="flex-column flex-grow-1 w-100 ps-0"><ul class="nav"><li class="nav-item"> <a href="/" class="nav-link"> <i class="fa-fw fas fa-home"></i> <span>HOME</span> </a><li class="nav-item"> <a href="/categories/" class="nav-link"> <i class="fa-fw fas fa-stream"></i> <span>CATEGORIES</span> </a><li class="nav-item"> <a href="/tags/" class="nav-link"> <i class="fa-fw fas fa-tags"></i> <span>TAGS</span> </a><li class="nav-item"> <a href="/archives/" class="nav-link"> <i class="fa-fw fas fa-archive"></i> <span>ARCHIVES</span> </a><li class="nav-item"> <a href="/about/" class="nav-link"> <i class="fa-fw fas fa-info-circle"></i> <span>ABOUT</span> </a></ul></nav><div class="sidebar-bottom d-flex flex-wrap align-items-center w-100"> <button type="button" class="btn btn-link nav-link" aria-label="Switch Mode" id="mode-toggle"> <i class="fas fa-adjust"></i> </button> <span class="icon-border"></span> <a href="https://github.com/pyemma" aria-label="github" target="_blank" rel="noopener noreferrer" > <i class="fab fa-github"></i> </a> <a href="https://twitter.com/" aria-label="twitter" target="_blank" rel="noopener noreferrer" > <i class="fa-brands fa-x-twitter"></i> </a> <a href="javascript:location.href = 'mailto:' + ['pyemma1991','gmail.com'].join('@')" aria-label="email" > <i class="fas fa-envelope"></i> </a> <a href="/feed.xml" aria-label="rss" > <i class="fas fa-rss"></i> </a></div></aside><div id="main-wrapper" class="d-flex justify-content-center"><div class="container d-flex flex-column px-xxl-5"><header id="topbar-wrapper" aria-label="Top Bar"><div id="topbar" class="d-flex align-items-center justify-content-between px-lg-3 h-100" ><nav id="breadcrumb" aria-label="Breadcrumb"> <span> <a href="/">Home</a> </span> <span>How to Design Auction System</span></nav><button type="button" id="sidebar-trigger" class="btn btn-link"> <i class="fas fa-bars fa-fw"></i> </button><div id="topbar-title"> Post</div><button type="button" id="search-trigger" class="btn btn-link"> <i class="fas fa-search fa-fw"></i> </button> <search id="search" class="align-items-center ms-3 ms-lg-0"> <i class="fas fa-search fa-fw"></i> <input class="form-control" id="search-input" type="search" aria-label="search" autocomplete="off" placeholder="Search..." > </search> <button type="button" class="btn btn-link text-decoration-none" id="search-cancel">Cancel</button></div></header><div class="row flex-grow-1"><main aria-label="Main Content" class="col-12 col-lg-11 col-xl-9 px-md-4"><article class="px-1"><header><h1 data-toc-skip>How to Design Auction System</h1><div class="post-meta text-muted"> <span> Posted <time data-ts="1712386800" data-df="ll" data-bs-toggle="tooltip" data-bs-placement="bottom" > Apr 6, 2024 </time> </span> <span> Updated <time data-ts="1728887223" data-df="ll" data-bs-toggle="tooltip" data-bs-placement="bottom" > Oct 13, 2024 </time> </span><div class="d-flex justify-content-between"> <span> By <em> <a href="https://github.com/pyemma">Coding Monkey</a> </em> </span><div> <span class="readtime" data-bs-toggle="tooltip" data-bs-placement="bottom" title="3729 words" > <em>20 min</em> read</span></div></div><div style="text-align: right;"> <span> <a href="https://hits.seeyoufarm.com/api/count/incr/badge.svg?url=https%3A%2F%2Fpyemma.github.io%2F/How-to-design-auction-system/&count_bg=%2379C83D&title_bg=%23555555&icon=&icon_color=%23E7E7E7&title=views&edge_flat=false" class="popup img-link shimmer"><img style="width: inherit;" src="https://hits.seeyoufarm.com/api/count/incr/badge.svg?url=https%3A%2F%2Fpyemma.github.io%2F/How-to-design-auction-system/&count_bg=%2379C83D&title_bg=%23555555&icon=&icon_color=%23E7E7E7&title=views&edge_flat=false" alt="Views" loading="lazy"></a> </span></div></div></header><div class="content"><p>In this post, let’s discuss a little bit how to design an auction system similar to the one on eBay, where owner could list their items in the system and others could place a bid on it. User with highest bid would be the winner of this auction and could buy it.</p><p>In a real world auction system, there are lots of components involved, such as the search (user could search active auction based on their interest), payment (winner need to make the payment) and inventory (owner could add new items). We would not dive deep into these components, but would only focus on the auction service itself. For search and payment, I plan to have other posts to discuss them in depth.</p><p>In this post, we would discuss 2 different ways to design the auction system, <em>stateful</em> and <em>stateless</em>, and see what would be their pros and cons. In reality, <em>stateless</em> is more common, while <em>stateful</em> design still play a critical role in different use cases, e.g. stream processing.</p><h2 id="functional-requirement"><span class="me-2">Functional Requirement</span><a href="#functional-requirement" class="anchor text-muted"><i class="fas fa-hashtag"></i></a></h2><p>We would assume the following functional requirement to be offered by our system</p><ul><li>User could start an auction<li>User could view the active auction, and place a bid in the auction; user could also get realtime update on the current highest bid<li>Auction is closed when there is no higher bid for 1 hour<li>Winner of the auction would receive notification and has 10 minutes to make the payment</ul><h2 id="non-functional-requirements"><span class="me-2">Non Functional Requirements</span><a href="#non-functional-requirements" class="anchor text-muted"><i class="fas fa-hashtag"></i></a></h2><ul><li>High availability<li>High scalability<li>Low latency<li>Eventual consistency is acceptable for live bidding part (we could discuss for higher consistency level), but when determine the winner of the auction, it needs strong consistency<li>1B DAU, 100k auctions per-day, on average 10% of user place 1 bid per day, assume 10:1 read:write ratio</ul><h2 id="some-questions-to-clarify"><span class="me-2">Some questions to clarify</span><a href="#some-questions-to-clarify" class="anchor text-muted"><i class="fas fa-hashtag"></i></a></h2><ul><li>What if there are multiple bids with the same price, who would be the winner?<ul><li>The first bidder would be the winner</ul><li>Do we allow a bidder to place multiple bids within the same auction?<ul><li>No, each bidder could only place 1 bid, but they could increase their bid if their original one is not winner</ul><li>Do we need to record all bids that user placed during the auction?<ul><li>This is great question, let’s keep all bid that users have placed instead of just winners</ul><li>What shall we do if there is no bid for certain auction, do we need user to provide a TTL?<ul><li>Let’s simplify the problem as of now and assume there is no TTL required</ul></ul><h2 id="high-level-design"><span class="me-2">High level design</span><a href="#high-level-design" class="anchor text-muted"><i class="fas fa-hashtag"></i></a></h2><p>Newton has said that</p><blockquote><p>If I have been able to see further, it was only because I stood on the shoulders of giants</p></blockquote><p>In this design, we would also stand on the shoulders of <em>giants</em>, which is <strong>live comment</strong> and <strong>cron job scheduler</strong>.</p><h3 id="auction-creation"><span class="me-2">Auction creation</span><a href="#auction-creation" class="anchor text-muted"><i class="fas fa-hashtag"></i></a></h3><p>This part is relative simple. We have <strong>Auction Service</strong> to handle the creation HTTP request from user. The auction service would write a new entry to the <code class="language-plaintext highlighter-rouge">auction_table</code> within <strong>Auction DB</strong> and update to cache. Below is an example schema of our auction table. Besides the regular metadata such as <code class="language-plaintext highlighter-rouge">owner_id</code>, <code class="language-plaintext highlighter-rouge">item_id</code> and <code class="language-plaintext highlighter-rouge">created_at</code>, there are 2 important fields, <code class="language-plaintext highlighter-rouge">status</code> and <code class="language-plaintext highlighter-rouge">expire_at</code>, which is critical for us to manage the transition of auction and handle the payment.</p><p><a href="/assets/auction_db.png" class="popup img-link shimmer"><img src="/assets/auction_db.png" alt="Auction Database" width="700" height="400" loading="lazy"></a></p><p>When we create a new auction, we would also update it into the cache and mark it as a <code class="language-plaintext highlighter-rouge">ACTIVE</code> auction. This design choice actually makes our auction service stateless: it does not need to maintain any data on the server regarding the auction. If it needs to know the status of an auction, it would query the cache and then do the necessary processing. The cache is primarily used to help us improve the read performance regarding the highest bid for a given auction. If DB write or cache update fails, we would return failure to client and client would retry the creation.</p><p>There might be issue that the status in cache and in Auction DB are inconsistent, we would dive deeper into this topic in <a href="#cache-and-auction-db-consistency">Cache and Auction DB consistency</a> section.</p><h3 id="auction-bid-place-and-update"><span class="me-2">Auction Bid Place and Update</span><a href="#auction-bid-place-and-update" class="anchor text-muted"><i class="fas fa-hashtag"></i></a></h3><p>For this part, there are 2 key problems we need to answer:</p><ol><li>the connection mechanism between client and our service<li>the mechanism to route highest bid to users who are viewing the current auction</ol><p>For the first problem, we would use a combination of <em>HTTP request</em> and <em>server sent event (SSE)</em>: to place a bid, we issue an HTTP request to <strong>Auction Service</strong>; while to receive highest bid from others, we leverage SSE connection with <strong>Bid Update Service</strong>. Other connection options are <em>HTTP long polling</em> and <em>websocket</em>. <em>HTTP long polling</em> is relative less efficient because client needs to repeatedly query the backend for new bids. <em>Websocket</em> is a little bit over killing in our scenario as we don’t expect each user viewing the auction actively place bids, thus a single direction connection is sufficient. However, <em>websocket</em> might also be applicable in some cases. A more detailed comparison between <em>websocket</em> and <em>SSE</em> is available in <a href="#websocket-and-sse">Websocket vs SSE</a>.</p><p>For the second problem, one naive approach is to write all bids into DB and let the <strong>Bid Update Service</strong> to poll the DB to see if there are new bids. This approach works if there is not much traffic, but is less efficient in our scale and would put too much pressure on DB (# of auction x 60 / # of granularity QPS from a single <strong>Bid Update Service</strong>). Here we would leverage a <em>hierarchy fan-out</em> mechanism to route the bids.</p><p><a href="/assets/auction_bid_update.png" class="popup img-link shimmer"><img src="/assets/auction_bid_update.png" alt="Auction Bid Update" width="700" height="400" loading="lazy"></a></p><p>When user first navigate to an auction page, we would retrieve the information about the auction through <em>Auction Service</em> via regular HTTP request. If the auction is still in <code class="language-plaintext highlighter-rouge">ACTIVE</code> status, user would build a SSE connection with one <strong>Bid Update Service</strong> (Load Balancer could randomly pick one). The <strong>Bid Update Service</strong> <code class="language-plaintext highlighter-rouge">bus1</code> would update its in-memory <em>subscription table</em> to record that a user <code class="language-plaintext highlighter-rouge">u1</code> is viewing auction <code class="language-plaintext highlighter-rouge">a1</code>. Also, this server would also make a request to <strong>Dispatcher</strong> specifying that itself is listening to <code class="language-plaintext highlighter-rouge">a1</code> and <strong>Dispatcher</strong> would also update its in-memory <em>subscription table</em>.</p><div class="language-python highlighter-rouge"><div class="code-header"> <span data-label-text="Python"><i class="fas fa-code fa-fw small"></i></span> <button aria-label="copy" data-title-succeed="Copied!"><i class="far fa-clipboard"></i></button></div><div class="highlight"><code><table class="rouge-table"><tbody><tr><td class="rouge-gutter gl"><pre class="lineno">1
2
3
4
5
6
7
8
9
</pre><td class="rouge-code"><pre><span class="c1"># bus1 subscription table
</span><span class="p">{</span>
    <span class="sh">'</span><span class="s">a1</span><span class="sh">'</span><span class="p">:</span> <span class="p">[</span><span class="sh">'</span><span class="s">u1</span><span class="sh">'</span><span class="p">,</span> <span class="sh">'</span><span class="s">u2</span><span class="sh">'</span><span class="p">],</span>
<span class="p">}</span>
<span class="c1"># dispatcher subscription table
</span><span class="p">{</span>
    <span class="sh">'</span><span class="s">a1</span><span class="sh">'</span><span class="p">:</span> <span class="p">[</span><span class="sh">'</span><span class="s">bus1</span><span class="sh">'</span><span class="p">],</span>
    <span class="sh">'</span><span class="s">a2</span><span class="sh">'</span><span class="p">:</span> <span class="p">[</span><span class="sh">'</span><span class="s">bus2</span><span class="sh">'</span><span class="p">],</span>
<span class="p">}</span>
</pre></table></code></div></div><p>When user make a bid, client would send a HTTP request to <strong>Auction Service</strong>, the node that handle the request would also make a request towards <strong>Dispatcher</strong>. The <strong>Dispatcher</strong> would check its internal <em>subscription table</em> to figure out which <strong>Bid Update Service</strong> (in this case <code class="language-plaintext highlighter-rouge">bus1</code>) needs this update. Once <code class="language-plaintext highlighter-rouge">bus1</code> receives the request, it would also check its internal <em>subscription table</em> to figure out which connected user it needs to send this update.</p><p>In the version we just described, <strong>Dispatcher</strong> is a <em>stateful</em> service because it needs to maintain the <em>subscription table</em>. If it is down, we won’t able to forward bid update anymore and thus making it highly available is critical to our system. The following options could be considered:</p><ol><li>Adopt <em>write ahead log</em> and <em>snapshot</em> to rebuild the state after failure<li>Replicate the state to external storage (e.g. KV store) so that other nodes could pick it up<li>Active standby node to be promoted to primary once original one fails</ol><p>Another consideration here is that we might be able to remove dispatcher, and just use coordination service or a distributed kv store to maintain the <em>subscription table</em>. <strong>Bid Update Service</strong> would directly make update to coordination service, and <strong>Auction Service</strong> directly query it to figure out the <strong>Bid Update Service</strong> it needs to send update to.</p><p>There are pros and cons of both approach</p><ul><li>Dispatcher<ul><li>pros: simplify <strong>Auction Service’s</strong> responsibility (SRP), could scale individually, handoff on retry<li>cons: slightly more complex overall architecture</ul><li>Without Dispatcher<ul><li>pros: simpler architecture, less maintenance cost<li>cons: <strong>Auction Service</strong> needs to handle forwarding and retry</ul></ul><p>If we would like to achieve higher consistency, such as each update needs to be sent to all users that is within the same auction. We could enable ACK among the services. For example, if certain <strong>Bid Update Service</strong> does not reply ACK to <strong>Dispatcher</strong>, <strong>Dispatcher</strong> would retry the request. It is possible that on the client side we receive duplicated events, but it is pretty simple to dedup as we only need to keep the highest bid.</p><p>It is still possible that certain bid update is lost during the transmission and it might not a big duel. The reason is that:</p><ul><li>During normal active auction, there would always new bids coming out, which overwrite the pervious one; so certain data loss on client side would not make a big issue.<li>The only critical one is the miss of highest bid, which would be the last bid on the current auction. We could set a timer on the client side, and if it has been 10mins since we receive last update on bid, we could issue a hard pull to <strong>Auction Service</strong> to get the latest bid information.</ul><p>Having discussed about how bids are routed to other users, let’s take a look how we maintain the current highest bid. When user make a bid, one instance of <strong>Auction Service</strong> is going to handle the request. It first check if the auction exists in <strong>cache</strong> or not, and see if the status of the auction is still <code class="language-plaintext highlighter-rouge">ACTIVE</code> status. If there is a cache miss, it reads <strong>Auction DB</strong> to check the status of the auction (this could happen but should be some corner case). If auction is still <code class="language-plaintext highlighter-rouge">ACTIVE</code>, then <strong>Auction Service</strong> write the bid into the bid table in <em>append</em> pattern, which is great for write throughput. This choice would result in multiple bids for a single user given an auction, and we would use the latest one as user’s final bid (<em>latest</em> could be determined by insertion time, or we could have client side request id which would be more robust). Once DB write is done and if the new bid is higher than the current one in cache, we would also update the information in cache and <strong>Auction Service</strong> would also send request to <strong>Dispatcher</strong> to deliver this new update to all clients.</p><p>It is possible that the DB write is failed or the cache update is failed. We would retry the request if is some transitional issue.</p><p>In the cache, we would store the following metadata</p><figure class="highlight"><pre><code class="language-python" data-lang="python"><span class="n">auction_id</span><span class="p">:</span> <span class="p">(</span><span class="n">status</span><span class="p">,</span> <span class="n">highest_bid</span><span class="p">,</span> <span class="n">highest_bidder_id</span><span class="p">,</span> <span class="n">updated_at</span><span class="p">,</span> <span class="n">expire_at</span><span class="p">)</span></code></pre></figure><p><code class="language-plaintext highlighter-rouge">status</code>, <code class="language-plaintext highlighter-rouge">highest_bid</code> and <code class="language-plaintext highlighter-rouge">highest_bidder_id</code> is relative straightforward. <code class="language-plaintext highlighter-rouge">updated_at</code> is used to record the staleness of the cached entry, <code class="language-plaintext highlighter-rouge">expire_at</code> is used as timer to trigger the auction execution (see <a href="#auction-bid-execution">Auction Bid Execution</a>). This state works because in our FR we assume that the same user could only modify his bidder to higher price instead of lower. If we allow user to bid lower, then we need to store all user’s bid or top 100 bid.</p><p>Since we cache auction state by <code class="language-plaintext highlighter-rouge">auction_id</code>, we could suffer from <em>hotspot</em> issue. For example, <strong>Wing Gundam Zero</strong> is so popular that everyone tries to bid it and we have lots of concurrent update to the cache. Below are some options that we could consider</p><ul><li>To deal with high volume of concurrent write request, we could use lease to coordinate the update to avoid potential <em>stale update</em>. The downside is that the update might need to retry multiple times to succeed.<li>If we choose quorum as our replication strategy, we could potentially set write commit to 1 to increase the write throughput and have customized conflict resolve (relative simple as <em>larger-is-winner</em>). This works because in our FR we assume that the same user could only place higher bid but not lower.</ul><h3 id="auction-bid-execution"><span class="me-2">Auction Bid Execution</span><a href="#auction-bid-execution" class="anchor text-muted"><i class="fas fa-hashtag"></i></a></h3><p>To execute the winner’s bid after 1 hour, we have a <strong>Fulfillment Service</strong>. This service is similar to a cron job scheduler that it periodically scan the state we have in cache and see if there is any bid that needs to be executed by checking the <code class="language-plaintext highlighter-rouge">status</code> and <code class="language-plaintext highlighter-rouge">expire_at</code>. Once it identify one bid that needs to be executed, it would also send a request to <strong>Auction DB</strong> to double check if this is indeed the winner bid we need to execute:</p><ul><li>If not, it would make a write to cache to correct the information in cache. This is similar to <em>read repair</em> in quorum replication.<li>If confirmed, then <strong>Fulfillment Service</strong> would update the status of the auction to be <code class="language-plaintext highlighter-rouge">PAYMENT_PENDING</code> in both DB and cache. The <code class="language-plaintext highlighter-rouge">expired_at</code> field in <code class="language-plaintext highlighter-rouge">auction_table</code> would be set based on the policy (e.g. 10mins in our case). The <code class="language-plaintext highlighter-rouge">winner_id</code>, <code class="language-plaintext highlighter-rouge">winner_bid_id</code>, <code class="language-plaintext highlighter-rouge">winner_price</code> would also be populated all together. And then send request to notification system to send a payment notification to the winner. This event update would also be sent via the <strong>Dispatcher</strong> to all live users in this auction.</ul><p><a href="/assets/auction_bid_execution.png" class="popup img-link shimmer"><img src="/assets/auction_bid_execution.png" alt="Auction Bid Execution" width="700" height="400" loading="lazy"></a></p><p>The actual payment would be handled by another dedicated system which we won’t discuss too much in details. But once the payment is done, the payment service would update the auction status to <code class="language-plaintext highlighter-rouge">SUCCEED</code>.</p><p>The <strong>Fulfillment Service</strong> would also periodically check the auction that is in <code class="language-plaintext highlighter-rouge">PAYMENT_PENDING</code> status and see if there is any auction that exceeds the deadline but still not <code class="language-plaintext highlighter-rouge">SUCCEED</code> yet, and move them to <code class="language-plaintext highlighter-rouge">FAILED</code> status.</p><p>Notice that in our design, the <strong>Fulfillment Service</strong> depends on the cache to trigger the bid execution. This requires us to have cache to be highly available (through strategy such as different replication mechanism). Another option is to directly have the <strong>Fulfillment Service</strong> to query the <strong>Auction DB</strong> where our ground truth data exists. It needs to perform a relative complex query to join <code class="language-plaintext highlighter-rouge">auction_table</code> with <code class="language-plaintext highlighter-rouge">bid_table</code> to find the wining bid of each <code class="language-plaintext highlighter-rouge">ACTIVE</code> auction and check if they need to be executed or not. This is one tradeoff we need to consider:</p><ul><li>use cache, pros is reduced latency, cons is potential inconsistency issue which cause missed execution<li>directly read db, pros is accurate and no missed execution, cons is high latency and more pressure on DB</ul><h3 id="final-stateless-architecture"><span class="me-2">Final Stateless Architecture</span><a href="#final-stateless-architecture" class="anchor text-muted"><i class="fas fa-hashtag"></i></a></h3><p>In the final design, we also introduce a <strong>Reconcile Service</strong> which help us to detect certain abnormal situation. For example, the payment has succeed but the auction status is not correctly updated.</p><p><a href="/assets/auction_all.png" class="popup img-link shimmer"><img src="/assets/auction_all.png" alt="Stateless Architecture" width="700" height="400" loading="lazy"></a></p><h2 id="stateful-choice"><span class="me-2">Stateful Choice</span><a href="#stateful-choice" class="anchor text-muted"><i class="fas fa-hashtag"></i></a></h2><p>The discussion above is mainly on the <em>stateless design</em>. In this section, we discuss a little bit about the <em>stateful design</em> and see how it would be different from the <em>stateless one</em>.</p><p><a href="/assets/auction_stateful.png" class="popup img-link shimmer"><img src="/assets/auction_stateful.png" alt="Stateful Architecture" width="700" height="400" loading="lazy"></a></p><p>We would make <strong>Auction Service</strong> stateful, which means that it would maintain all bid related data for an auction. Once owner create an auction, it would be randomly assigned to a <strong>Auction Service</strong> and all bid for this auction would be handled through this instance. To minimize the latency, we could make the state maintained in memory. But similar to <strong>Dispatcher</strong>, we still need to make it highly available. <em>WAL</em> + <em>snapshot</em> or rebuilding from <strong>Auction DB</strong> are available options.</p><p>If user make a bid, we would leverage the load balancer to route this request to the right <strong>Auction Service</strong> instance to handle it (<em>service discover</em>). We don’t need another cron job scheduler to check if there is any bid needs to be executed, all these information is already available within the instance and it could handle that correctly.</p><p>We could take a simple comparison between <em>stateful</em> and <em>stateless</em></p><div class="table-wrapper"><table><thead><tr><th> <th>stateful<th>stateless<tbody><tr><td>consistency<td>easier to achieve high consistency as all data related to an auction is handled by a single server, for example we don’t need a separate fulfillment service to check if there is a bid to be executed<td>more challenging because there could be concurrent data write on the same auction handled by different servers<tr><td>availability<td>more challenging to achieve as we need to replicate the stateful data<td>easier to handle as the server is stateless and all state data is handled by external storage<tr><td>scalability<td>more challenging to scale, especially hotspot<td>easier to scale as we could add more machines and evenly balance the traffic</table></div><h2 id="additional-discussion"><span class="me-2">Additional Discussion</span><a href="#additional-discussion" class="anchor text-muted"><i class="fas fa-hashtag"></i></a></h2><p>In this section, we discuss about several additional points about the design.</p><h3 id="high-availability"><span class="me-2">High Availability</span><a href="#high-availability" class="anchor text-muted"><i class="fas fa-hashtag"></i></a></h3><p>During the high level design discussion, we have touched a little bit about how to achieve high availability in each component. In this section, we summarize the key points and add some additional ones.</p><ul><li><strong>Auction Service</strong><ul><li>in the <em>stateless</em> design, there is not much concern here, if the node is down before response back to client, the client would just retry and another node would help server the request. There might be duplicated write/update but it is fine in our case<ul><li>the auction creation could use upsert and check if there is the same <code class="language-plaintext highlighter-rouge">user_id</code> and <code class="language-plaintext highlighter-rouge">item_id</code> combination within a time rage for dedup<li>the bid is designed to be in appends and only the last one (by request id or injection time) would be used as the user’s final bid<li>the update to cache is fine regarding duplicated ones</ul><li>in the <em>stateful</em> design, we need to replicate the service state, by having follower node or snapshot the state to external storage</ul><li><strong>Dispatcher</strong>: this is also a <em>stateful</em> service and the strategy is similar to the <em>stateful</em> <strong>Auction Service</strong><li><strong>Cache, Auction DB, KV Store</strong>: different replication strategy could be discussed here, such as single leader, multi leader and quorum based. If you are not familiar with these concepts, please refer to the video below learn more details</ul><iframe class="embed-video" loading="lazy" src="https://www.youtube.com/embed/X8IhZx7fg24" title="YouTube video player" frameborder="0" allow="accelerometer; autoplay; clipboard-write; encrypted-media; gyroscope; picture-in-picture" allowfullscreen=""></iframe><ul><li><strong>Bid Update Service</strong>: even though these service are also stateful because they need to maintain the connection with client, we don’t need to replicate them nor persistent the information similar to other <em>stateful</em> service. The reason is that: 1. this stateful information is coupled with the liveness of this service, if the node is down, the connection has to be rebuild with other nodes; 2. the stateful information is not shareable with other nodes<li><strong>Fulfillment Service</strong>: this is also stateless and we could have a active standby to take the work once the primary one is done</ul><h3 id="high-scalability"><span class="me-2">High Scalability</span><a href="#high-scalability" class="anchor text-muted"><i class="fas fa-hashtag"></i></a></h3><p>We didn’t talk too much about how the system could scale.</p><ul><li><strong>Auction Service</strong><ul><li>in the <em>stateless</em> design, it is pretty easy to scale as we could add more nodes to improve the request that we could handle<li>in the <em>stateful</em> design, we could scale it via sharding by <code class="language-plaintext highlighter-rouge">owner_id</code>; sharding by <code class="language-plaintext highlighter-rouge">auction_id</code> is an option if we have a separate id generator to assign it upon the creation request</ul><li><strong>Dispatcher</strong>: the size of the <code class="language-plaintext highlighter-rouge">subscription_table</code> is manageable (# of bid update server x 100k x 8 bytes ~ GB level), thus a single sever should be sufficient; however, the size of data is only one dimension we need to consider when scale the system, the QPS would also be a factor that we need to consider. For <strong>Dispatcher</strong>, it needs to deal with pretty high volume of request, thus we could add read replica to improve the throughput (sync replication for stronger consistency or async for eventual consistency), or we could also shard it by <code class="language-plaintext highlighter-rouge">auction_id</code><li><strong>Cache, Auction DB, KV Store</strong>: different sharding strategy could be discussed here, such as partition by <code class="language-plaintext highlighter-rouge">auction_id</code> (which offers good co-locate property for the <code class="language-plaintext highlighter-rouge">auction_table</code> and <code class="language-plaintext highlighter-rouge">bid_table</code> but has the downside of hotspot); or partition by <code class="language-plaintext highlighter-rouge">user_id</code> (which might better distribute the write as is it relative rare for someone that becomes a hotspot and they could be rate limited)<li><strong>Bid Update Service</strong>: it is also easy to scale by adding more nodes because they only keep in-memory <code class="language-plaintext highlighter-rouge">subscription_table</code><li><strong>Fulfillment Service</strong>: we could shard it by <code class="language-plaintext highlighter-rouge">auction_id</code> to evenly distribute the processing to more nodes</ul><h3 id="cache-and-auction-db-consistency"><span class="me-2">Cache and Auction DB consistency</span><a href="#cache-and-auction-db-consistency" class="anchor text-muted"><i class="fas fa-hashtag"></i></a></h3><p>In our <em>stateless</em> design, we store all data into <strong>Auction DB</strong>, and also store highest bid related information for each auction in a cache. We adopted something similar to <em>write through</em>, in which we write DB first and then update the cache; another option to consider is <em>write back</em>, in which we update cache first, and then at sometime later right back to DB. <em>Write back</em> could be used if we decided to in real time update the winning bid into the <code class="language-plaintext highlighter-rouge">auction_table</code> to reduce the volume of write request.</p><p>It is possible that we write to DB success but failed to update cache. For example, the request to update cache is failed or the node is down before try to update the cache. Retry could be used here, but it could still possible that the update to cache is failed after several retry. But since our <strong>Fulfillment Service</strong> reads the cache to execute the bid, it might read some outdated data because of the above potential failure. That is also why we have <code class="language-plaintext highlighter-rouge">updated_at</code> field to track if we should read from DB again to see if the data is up-to-date. Also upon serving request from client on pulling highest bid, we leverage <code class="language-plaintext highlighter-rouge">updated_at</code> to do a <em>read repair</em> to fix the potential out of date.</p><h3 id="websocket-and-sse"><span class="me-2">Websocket and SSE</span><a href="#websocket-and-sse" class="anchor text-muted"><i class="fas fa-hashtag"></i></a></h3><p><em>Websocket</em> and <em>SSE</em> are 2 common way we build a connection with backend and keep it live to send/receive data; instead of repeatedly creating new request and sent it over. Below is a simple comparison of these 2 approach</p><div class="table-wrapper"><table><thead><tr><th> <th>Websocket<th>SSE<tbody><tr><td>communication<td>bi-direction<td>single direction<tr><td>support<td>most modern browser already supported<td>limited browser support<tr><td>failure<td>could not reconnect and need to establish a new one<td>could reconnect<tr><td>data type<td>support both text and binary data<td>text data only<tr><td>application<td>realtime messaging, online gaming<td>stock monitor, live comment</table></div><p>In our current design, we are establish a new SSE whenever user navigate to a new auction. Another design choice here is to let user establish a new connection upon login to our application. And keep a <em>websocket</em> connection. Whenever user navigate to another auction, it would send this event over the <em>websocket</em> so that the <strong>Bid Update Service</strong> could update the <code class="language-plaintext highlighter-rouge">subscription table</code>. Depends on the pattern of how general users are interacting with our system, we could optimize the choice of the connection mechanism.</p><blockquote class="prompt-tip"><p>If you find this post helpful, feel free to scan the QR code below to support me and treat me to a cup of coffee</p></blockquote><p><a href="/assets/qr%20code.png" class="popup img-link shimmer"><img src="/assets/qr%20code.png" alt="Thank You" width="300" height="300" loading="lazy"></a></p><h2 id="reference"><span class="me-2">Reference</span><a href="#reference" class="anchor text-muted"><i class="fas fa-hashtag"></i></a></h2><ul><li><a href="https://www.infoq.com/presentations/linkedin-play-akka-distributed-systems/">Streaming a Million Likes/Second: Real-Time Interactions on Live Video</a><li><a href="https://dropbox.tech/infrastructure/asynchronous-task-scheduling-at-dropbox">How we designed Dropbox ATF: an async task framework</a><li><a href="https://dataintensive.net/">Design Data-Intensive Applications</a><li><a href="https://www.infoq.com/news/2015/11/scaling-stateful-services/">Scaling Stateful Service</a><li><a href="https://stackoverflow.com/questions/5195452/websockets-vs-server-sent-events-eventsource">Difference between Websockets and Server Sent Events</a><li><a href="https://www.usenix.org/system/files/conference/nsdi13/nsdi13-final170_update.pdf">Scaling Memcache at Facebook</a><li><a href="https://www.oreilly.com/library/view/stream-processing-with/9781491974285/">Stream Processing with Apache Flink</a><li><a href="https://youtu.be/85uigxGitIg?si=H6JFhiylr0OXphYt">DDIA Chapter 6 Partition</a></ul><iframe class="embed-video" loading="lazy" src="https://www.youtube.com/embed/85uigxGitIg" title="YouTube video player" frameborder="0" allow="accelerometer; autoplay; clipboard-write; encrypted-media; gyroscope; picture-in-picture" allowfullscreen=""></iframe><h3 id="acknowledgement"><span class="me-2">Acknowledgement</span><a href="#acknowledgement" class="anchor text-muted"><i class="fas fa-hashtag"></i></a></h3><p>Thanks Rita and Celia for the great discussion and lots of idea.</p></div><div class="post-tail-wrapper text-muted"><div class="post-meta mb-3"> <i class="far fa-folder-open fa-fw me-1"></i> <a href="/categories/distributed-system/">Distributed System</a></div><div class="post-tags"> <i class="fa fa-tags fa-fw me-1"></i> <a href="/tags/system-design/" class="post-tag no-text-decoration" >system design</a> <a href="/tags/auction/" class="post-tag no-text-decoration" >auction</a> <a href="/tags/realtime-system/" class="post-tag no-text-decoration" >realtime system</a></div><div class=" post-tail-bottom d-flex justify-content-between align-items-center mt-5 pb-2 " ><div class="license-wrapper"> This post is licensed under <a href="https://creativecommons.org/licenses/by/4.0/"> CC BY 4.0 </a> by the author.</div><div class="share-wrapper d-flex align-items-center"> <span class="share-label text-muted">Share</span> <span class="share-icons"> <a href="https://twitter.com/intent/tweet?text=How%20to%20Design%20Auction%20System%20-%20Coding%20Monkey&url=https%3A%2F%2Fpyemma.github.io%2FHow-to-design-auction-system%2F" target="_blank" rel="noopener" data-bs-toggle="tooltip" data-bs-placement="top" title="Twitter" aria-label="Twitter"> <i class="fa-fw fa-brands fa-square-x-twitter"></i> </a> <a href="https://www.facebook.com/sharer/sharer.php?title=How%20to%20Design%20Auction%20System%20-%20Coding%20Monkey&u=https%3A%2F%2Fpyemma.github.io%2FHow-to-design-auction-system%2F" target="_blank" rel="noopener" data-bs-toggle="tooltip" data-bs-placement="top" title="Facebook" aria-label="Facebook"> <i class="fa-fw fab fa-facebook-square"></i> </a> <a href="https://t.me/share/url?url=https%3A%2F%2Fpyemma.github.io%2FHow-to-design-auction-system%2F&text=How%20to%20Design%20Auction%20System%20-%20Coding%20Monkey" target="_blank" rel="noopener" data-bs-toggle="tooltip" data-bs-placement="top" title="Telegram" aria-label="Telegram"> <i class="fa-fw fab fa-telegram"></i> </a> <button id="copy-link" aria-label="Copy link" class="btn small" data-bs-toggle="tooltip" data-bs-placement="top" title="Copy link" data-title-succeed="Link copied successfully!" > <i class="fa-fw fas fa-link pe-none fs-6"></i> </button> </span></div></div></div></article></main><aside aria-label="Panel" id="panel-wrapper" class="col-xl-3 ps-2 mb-5 text-muted"><div class="access"><section id="access-lastmod"><h2 class="panel-heading">Recently Updated</h2><ul class="content list-unstyled ps-0 pb-1 ms-1 mt-2"><li class="text-truncate lh-lg"> <a href="/Machine-Learning-System-Design-Sparse-Features/">Trend of Sparse Features in Recommendation System</a><li class="text-truncate lh-lg"> <a href="/How-to-design-online-chess-game/">How to Design Online Chess Game</a><li class="text-truncate lh-lg"> <a href="/DDIA-Stream-Processing-I/">DDIA Chapter 11 Stream Processing Part I</a><li class="text-truncate lh-lg"> <a href="/How-to-Design-Webhook/">How to Design Webhook</a><li class="text-truncate lh-lg"> <a href="/How-to-design-auction-system/">How to Design Auction System</a></ul></section><section><h2 class="panel-heading">Trending Tags</h2><div class="d-flex flex-wrap mt-3 mb-1 me-3"> <a class="post-tag btn btn-outline-primary" href="/tags/system-design/">system design</a> <a class="post-tag btn btn-outline-primary" href="/tags/llm/">llm</a> <a class="post-tag btn btn-outline-primary" href="/tags/machine-learning-design/">machine learning design</a> <a class="post-tag btn btn-outline-primary" href="/tags/message-queue/">message queue</a> <a class="post-tag btn btn-outline-primary" href="/tags/realtime-system/">realtime system</a> <a class="post-tag btn btn-outline-primary" href="/tags/auction/">auction</a> <a class="post-tag btn btn-outline-primary" href="/tags/distributed-system/">distributed system</a> <a class="post-tag btn btn-outline-primary" href="/tags/embeddings/">embeddings</a> <a class="post-tag btn btn-outline-primary" href="/tags/feature/">feature</a> <a class="post-tag btn btn-outline-primary" href="/tags/job-scheduler/">job scheduler</a></div></section></div><section id="toc-wrapper" class="d-none ps-0 pe-4"><h2 class="panel-heading ps-3 mb-2">Contents</h2><nav id="toc"></nav></section></aside></div><div class="row"><div id="tail-wrapper" class="col-12 col-lg-11 col-xl-9 px-md-4"><aside id="related-posts" aria-labelledby="related-label"><h3 class="mb-4" id="related-label">Further Reading</h3><nav class="row row-cols-1 row-cols-md-2 row-cols-xl-3 g-4 mb-4"><article class="col"> <a href="/DDIA-Stream-Processing-I/" class="post-preview card h-100"><div class="card-body"> <time data-ts="1700553600" data-df="ll" > Nov 21, 2023 </time><h4 class="pt-0 my-2">DDIA Chapter 11 Stream Processing Part I</h4><div class="text-muted"><p>In this post, we would introduce stream processing. Since it is a large topic, we would break it down into 2 part, and in the first part, we would focus on the component that is related to the “flo...</p></div></div></a></article><article class="col"> <a href="/Book-Pattern-of-Distributed-System/" class="post-preview card h-100"><div class="card-body"> <time data-ts="1720162800" data-df="ll" > Jul 5, 2024 </time><h4 class="pt-0 my-2">读书笔记 - Patterns of Distributed System</h4><div class="text-muted"><p>最近读了一本和 distributed system 相关的书籍，介绍了在 distributed system 里面常用的一些 pattern. 这是一篇简要的读书笔记，把书中提到的几个 pattern 总结了下来; 我计划会经常更新这篇 blog, 把我新学习到的或者总结出来的一些 pattern 记录在这里; 希望能起到一个引导性的作用，给大家提供一个提纲挈领的思路 Patterns...</p></div></div></a></article><article class="col"> <a href="/How-to-Design-Webhook/" class="post-preview card h-100"><div class="card-body"> <time data-ts="1701590400" data-df="ll" > Dec 3, 2023 </time><h4 class="pt-0 my-2">How to Design Webhook</h4><div class="text-muted"><p>Today, let’s discuss about how to design a system that could let customer to register webhook and send webhook requests to destination. Let’s first align on some terms that we are going to use acr...</p></div></div></a></article></nav></aside><nav class="post-navigation d-flex justify-content-between" aria-label="Post Navigation"> <a href="/How-to-use-GPT-for-recommendation-task/" class="btn btn-outline-primary" aria-label="Older" ><p>How to use LLM for recommendation task</p></a> <a href="/Features-in-Recommendation-System/" class="btn btn-outline-primary" aria-label="Newer" ><p>那些年，我们追过的 Feature</p></a></nav><div id="disqus_thread"><p class="text-center text-muted small">Comments powered by <a href="https://disqus.com/">Disqus</a>.</p></div><script type="text/javascript"> var disqus_config = function () { this.page.url = 'https://pyemma.github.io/How-to-design-auction-system/'; this.page.identifier = '/How-to-design-auction-system/'; };var disqus_observer = new IntersectionObserver( function (entries) { if (entries[0].isIntersecting) { (function () { var d = document, s = d.createElement('script'); s.src = 'https://pyemma.disqus.com/embed.js'; s.setAttribute('data-timestamp', +new Date()); (d.head || d.body).appendChild(s); })(); disqus_observer.disconnect(); } }, { threshold: [0] } ); disqus_observer.observe(document.getElementById('disqus_thread'));function reloadDisqus() { if (event.source === window && event.data && event.data.direction === ModeToggle.ID) {if (typeof DISQUS === 'undefined') { return; } if (document.readyState == 'complete') { DISQUS.reset({ reload: true, config: disqus_config }); } } } if (document.getElementById('mode-toggle')) { window.addEventListener('message', reloadDisqus); } </script><footer aria-label="Site Info" class=" d-flex flex-column justify-content-center text-muted flex-lg-row justify-content-lg-between align-items-lg-center pb-lg-3 " ><p>© <time>2024</time> <a href="https://github.com/pyemma">Coding Monkey</a>. <span data-bs-toggle="tooltip" data-bs-placement="top" title="Except where otherwise noted, the blog posts on this site are licensed under the Creative Commons Attribution 4.0 International (CC BY 4.0) License by the author." >Some rights reserved.</span></p><p>Using the <a data-bs-toggle="tooltip" data-bs-placement="top" title="v7.1.1" href="https://github.com/cotes2020/jekyll-theme-chirpy" target="_blank" rel="noopener" >Chirpy</a> theme for <a href="https://jekyllrb.com" target="_blank" rel="noopener">Jekyll</a>.</p></footer></div></div><div id="search-result-wrapper" class="d-flex justify-content-center d-none"><div class="col-11 content"><div id="search-hints"><section><h2 class="panel-heading">Trending Tags</h2><div class="d-flex flex-wrap mt-3 mb-1 me-3"> <a class="post-tag btn btn-outline-primary" href="/tags/system-design/">system design</a> <a class="post-tag btn btn-outline-primary" href="/tags/llm/">llm</a> <a class="post-tag btn btn-outline-primary" href="/tags/machine-learning-design/">machine learning design</a> <a class="post-tag btn btn-outline-primary" href="/tags/message-queue/">message queue</a> <a class="post-tag btn btn-outline-primary" href="/tags/realtime-system/">realtime system</a> <a class="post-tag btn btn-outline-primary" href="/tags/auction/">auction</a> <a class="post-tag btn btn-outline-primary" href="/tags/distributed-system/">distributed system</a> <a class="post-tag btn btn-outline-primary" href="/tags/embeddings/">embeddings</a> <a class="post-tag btn btn-outline-primary" href="/tags/feature/">feature</a> <a class="post-tag btn btn-outline-primary" href="/tags/job-scheduler/">job scheduler</a></div></section></div><div id="search-results" class="d-flex flex-wrap justify-content-center text-muted mt-3"></div></div></div></div><aside aria-label="Scroll to Top"> <button id="back-to-top" type="button" class="btn btn-lg btn-box-shadow"> <i class="fas fa-angle-up"></i> </button></aside></div><div id="mask"></div><aside id="notification" class="toast" role="alert" aria-live="assertive" aria-atomic="true" data-bs-animation="true" data-bs-autohide="false" ><div class="toast-header"> <button type="button" class="btn-close ms-auto" data-bs-dismiss="toast" aria-label="Close" ></button></div><div class="toast-body text-center pt-0"><p class="px-2 mb-3">A new version of content is available.</p><button type="button" class="btn btn-primary" aria-label="Update"> Update </button></div></aside><script src="https://cdn.jsdelivr.net/combine/npm/simple-jekyll-search@1.10.0/dest/simple-jekyll-search.min.js,npm/loading-attribute-polyfill@2.1.1/dist/loading-attribute-polyfill.umd.min.js,npm/glightbox@3.3.0/dist/js/glightbox.min.js,npm/clipboard@2.0.11/dist/clipboard.min.js,npm/dayjs@1.11.13/dayjs.min.js,npm/dayjs@1.11.13/locale/en.js,npm/dayjs@1.11.13/plugin/relativeTime.js,npm/dayjs@1.11.13/plugin/localizedFormat.js,npm/tocbot@4.29.0/dist/tocbot.min.js"></script> <script src="/assets/js/dist/post.min.js"></script> <script defer src="/app.min.js?baseurl=&register=true" ></script> <script defer src="https://www.googletagmanager.com/gtag/js?id=G-M1GM2SJR6M"></script> <script> document.addEventListener('DOMContentLoaded', function (event) { window.dataLayer = window.dataLayer || []; function gtag() { dataLayer.push(arguments); } gtag('js', new Date()); gtag('config', 'G-M1GM2SJR6M'); }); </script> <script>SimpleJekyllSearch({ searchInput: document.getElementById('search-input'), resultsContainer: document.getElementById('search-results'), json: '/assets/js/data/search.json', searchResultTemplate: '<article class="px-1 px-sm-2 px-lg-4 px-xl-0"><header><h2><a href="{url}">{title}</a></h2><div class="post-meta d-flex flex-column flex-sm-row text-muted mt-1 mb-1"> {categories} {tags}</div></header><p>{snippet}</p></article>', noResultsText: '<p class="mt-5">Oops! No results found.</p>', templateMiddleware: function(prop, value, template) { if (prop === 'categories') { if (value === '') { return `${value}`; } else { return `<div class="me-sm-4"><i class="far fa-folder fa-fw"></i>${value}</div>`; } } if (prop === 'tags') { if (value === '') { return `${value}`; } else { return `<div><i class="fa fa-tag fa-fw"></i>${value}</div>`; } } } }); </script>
